# TOPSIS åŒºé—´ç‰ˆæœ¬ç®—æ³•è¯¦è§£

**ç®—æ³•åç§°**: TOPSISï¼ˆTechnique for Order Preference by Similarity to Ideal Solutionï¼‰åŒºé—´ç‰ˆæœ¬
**å®ç°æ–‡ä»¶**: `skills/mcda-core/lib/algorithms/topsis_interval.py`

---

## ğŸ“– ç®—æ³•åŸç†

### TOPSIS åŸºæœ¬æ€æƒ³

TOPSISï¼ˆé€¼è¿‘ç†æƒ³è§£æ’åºæ³•ï¼‰ç”± Hwang å’Œ Yoon äº 1981 å¹´æå‡ºï¼Œæ˜¯ä¸€ç§åŸºäºè·ç¦»çš„å¤šå‡†åˆ™å†³ç­–æ–¹æ³•ã€‚

**æ ¸å¿ƒå‡è®¾**: æœ€ä¼˜æ–¹æ¡ˆåº”è¯¥ï¼š
1. è·ç¦»**æ­£ç†æƒ³è§£**ï¼ˆPositive Ideal Solution, PISï¼‰**æœ€è¿‘**
2. è·ç¦»**è´Ÿç†æƒ³è§£**ï¼ˆNegative Ideal Solution, NISï¼‰**æœ€è¿œ**

### åŒºé—´ç‰ˆæœ¬æ‰©å±•

å½“è¯„åˆ†å­˜åœ¨ä¸ç¡®å®šæ€§æ—¶ï¼Œä½¿ç”¨åŒºé—´æ•°è¡¨ç¤ºï¼š

$$\tilde{x}_{ij} = [x_{ij}^L, x_{ij}^U]$$

åŒºé—´ç‰ˆæœ¬é€šè¿‡ä»¥ä¸‹æ–¹å¼å¤„ç†ä¸ç¡®å®šæ€§ï¼š
1. ä½¿ç”¨åŒºé—´ä¸­ç‚¹è¿›è¡Œè®¡ç®—
2. ä¿æŒç®—æ³•çš„è·ç¦»åº¦é‡ç‰¹æ€§
3. æä¾›ç›¸å¯¹æ¥è¿‘åº¦ä½œä¸ºæ’åºä¾æ®

---

## ğŸ§® æ•°å­¦æ¨å¯¼

### é—®é¢˜å®šä¹‰

ç»™å®šï¼š
- $m$ ä¸ªå¤‡é€‰æ–¹æ¡ˆï¼š$A = \{A_1, A_2, ..., A_m\}$
- $n$ ä¸ªå‡†åˆ™ï¼š$C = \{C_1, C_2, ..., C_n\}$
- æƒé‡å‘é‡ï¼š$W = \{w_1, w_2, ..., w_n\}$ï¼Œ$\sum w_j = 1$
- åŒºé—´å†³ç­–çŸ©é˜µï¼š$\tilde{X} = [\tilde{x}_{ij}]_{m \times n}$

### Step 1: Vector æ ‡å‡†åŒ–

**ç›®çš„**: æ¶ˆé™¤ä¸åŒå‡†åˆ™çš„é‡çº²å½±å“ã€‚

**å…¬å¼**:

$$r_{ij} = \frac{x_{ij}}{\sqrt{\sum_{i=1}^{m} x_{ij}^2}}$$

**åŒºé—´å¤„ç†**:

å¯¹äºåŒºé—´æ•° $\tilde{x}_{ij} = [x_{ij}^L, x_{ij}^U]$ï¼š

$$\text{midpoint}(\tilde{x}_{ij}) = \frac{x_{ij}^L + x_{ij}^U}{2}$$

$$r_{ij} = \frac{\text{midpoint}(\tilde{x}_{ij})}{\sqrt{\sum_{i=1}^{m} \text{midpoint}(\tilde{x}_{ij})^2}}$$

**æ€§è´¨**: æ ‡å‡†åŒ–åï¼Œ$\sum_{i=1}^{m} r_{ij}^2 = 1$

**ç¤ºä¾‹**:

å‡è®¾æœ‰ä¸‰ä¸ªæ–¹æ¡ˆåœ¨æŸå‡†åˆ™ä¸Šçš„è¯„åˆ†ä¸ºï¼š$[3, 5], [4, 6], [5, 7]$

1. è®¡ç®—ä¸­ç‚¹ï¼š$4, 5, 6$
2. è®¡ç®—å¹³æ–¹å’Œï¼š$4^2 + 5^2 + 6^2 = 16 + 25 + 36 = 77$
3. è®¡ç®—èŒƒæ•°ï¼š$\sqrt{77} \approx 8.775$
4. æ ‡å‡†åŒ–ï¼š
   - $r_1 = 4 / 8.775 \approx 0.456$
   - $r_2 = 5 / 8.775 \approx 0.570$
   - $r_3 = 6 / 8.775 \approx 0.684$

### Step 2: åŠ æƒæ ‡å‡†åŒ–

**ç›®çš„**: åæ˜ å‡†åˆ™çš„ç›¸å¯¹é‡è¦æ€§ã€‚

**å…¬å¼**:

$$v_{ij} = w_j \cdot r_{ij}$$

**ç¤ºä¾‹**:

è‹¥æƒé‡ $w_j = 0.4$ï¼Œåˆ™ï¼š
- $v_1 = 0.4 \times 0.456 = 0.182$
- $v_2 = 0.4 \times 0.570 = 0.228$
- $v_3 = 0.4 \times 0.684 = 0.274$

### Step 3: ç¡®å®šç†æƒ³è§£å’Œè´Ÿç†æƒ³è§£

**æ•ˆç›Šå‹å‡†åˆ™ï¼ˆhigher_betterï¼‰**:

$$v_j^+ = \max_i \{v_{ij}\}, \quad v_j^- = \min_i \{v_{ij}\}$$

**æˆæœ¬å‹å‡†åˆ™ï¼ˆlower_betterï¼‰**:

$$v_j^+ = \min_i \{v_{ij}\}, \quad v_j^- = \max_i \{v_{ij}\}$$

**ç¤ºä¾‹**:

å‡è®¾æœ‰ä¸‰ä¸ªå‡†åˆ™ï¼Œå…¶ä¸­ C2 æ˜¯æˆæœ¬å‹ï¼š

| å‡†åˆ™ | C1 (æ•ˆç›Š) | C2 (æˆæœ¬) | C3 (æ•ˆç›Š) |
|------|-----------|-----------|-----------|
| A1   | 0.182     | 0.228     | 0.150     |
| A2   | 0.274     | 0.150     | 0.200     |
| A3   | 0.200     | 0.200     | 0.180     |

ç†æƒ³è§£ï¼š$v^+ = (0.274, 0.150, 0.200)$
è´Ÿç†æƒ³è§£ï¼š$v^- = (0.182, 0.228, 0.150)$

### Step 4: è®¡ç®—è·ç¦»

ä½¿ç”¨æ¬§æ°è·ç¦»ï¼š

$$D_i^+ = \sqrt{\sum_{j=1}^{n} (v_{ij} - v_j^+)^2}$$

$$D_i^- = \sqrt{\sum_{j=1}^{n} (v_{ij} - v_j^-)^2}$$

**ç¤ºä¾‹ï¼ˆA1 çš„è·ç¦»ï¼‰**:

$$D_1^+ = \sqrt{(0.182-0.274)^2 + (0.228-0.150)^2 + (0.150-0.200)^2}$$
$$D_1^+ = \sqrt{0.0085 + 0.0061 + 0.0025} = \sqrt{0.0171} \approx 0.131$$

$$D_1^- = \sqrt{(0.182-0.182)^2 + (0.228-0.228)^2 + (0.150-0.150)^2} = 0$$

### Step 5: ç›¸å¯¹æ¥è¿‘åº¦

$$C_i = \frac{D_i^-}{D_i^+ + D_i^-}$$

**æ€§è´¨**:
1. $C_i \in [0, 1]$
2. $C_i = 1 \iff D_i^+ = 0$ï¼ˆä¸ç†æƒ³è§£é‡åˆï¼‰
3. $C_i = 0 \iff D_i^- = 0$ï¼ˆä¸è´Ÿç†æƒ³è§£é‡åˆï¼‰

**å‡ ä½•è§£é‡Š**:

ç›¸å¯¹æ¥è¿‘åº¦è¡¨ç¤ºæ–¹æ¡ˆåœ¨ç†æƒ³è§£ä¸è´Ÿç†æƒ³è§£è¿çº¿ä¸Šçš„ç›¸å¯¹ä½ç½®ï¼š

```
è´Ÿç†æƒ³è§£ (NIS) -------- æ–¹æ¡ˆ -------- æ­£ç†æƒ³è§£ (PIS)
     D_i^-                  D_i^+

     C_i = D_i^- / (D_i^+ + D_i^-)
```

---

## ğŸ”§ å®ç°ç»†èŠ‚

### ç±»ç»“æ„

```python
@register_algorithm("topsis_interval")
class IntervalTOPSISAlgorithm(MCDAAlgorithm):
    """é€¼è¿‘ç†æƒ³è§£æ’åºæ³•ï¼ˆåŒºé—´ç‰ˆæœ¬ï¼‰"""

    def calculate(self, problem: DecisionProblem, **kwargs) -> DecisionResult:
        # 1. éªŒè¯è¾“å…¥
        # 2. æ„å»ºå¾—åˆ†çŸ©é˜µ
        # 3. Vector æ ‡å‡†åŒ–
        # 4. åº”ç”¨æƒé‡
        # 5. ç¡®å®šç†æƒ³è§£/è´Ÿç†æƒ³è§£
        # 6. è®¡ç®—è·ç¦»
        # 7. è®¡ç®—ç›¸å¯¹æ¥è¿‘åº¦
        # 8. æ„å»ºæ’å
        # 9. è¿”å›ç»“æœ
```

### å…³é”®æ–¹æ³•

#### 1. _vector_normalize

```python
def _vector_normalize(self, scores_matrix, criteria):
    """Vector æ ‡å‡†åŒ–"""
    for k in range(n_crit):
        # è®¡ç®—è¯¥å‡†åˆ™çš„å¹³æ–¹å’Œï¼ˆä½¿ç”¨ä¸­ç‚¹ï¼‰
        sum_squares = 0.0
        for i in range(n_alt):
            val = scores_matrix[i, k]
            if isinstance(val, Interval):
                sum_squares += val.midpoint ** 2
            else:
                sum_squares += float(val) ** 2

        norm = math.sqrt(sum_squares)
        if norm < 1e-10:
            norm = 1.0  # é¿å…é™¤é›¶

        # æ ‡å‡†åŒ–
        for i in range(n_alt):
            val = scores_matrix[i, k]
            if isinstance(val, Interval):
                normalized[i, k] = Interval(
                    val.lower / norm,
                    val.upper / norm
                )
            else:
                normalized[i, k] = val / norm
```

#### 2. _find_ideal_solutions

```python
def _find_ideal_solutions(self, weighted, criteria):
    """ç¡®å®šç†æƒ³è§£å’Œè´Ÿç†æƒ³è§£"""
    for k in range(n_crit):
        # æå–è¯¥å‡†åˆ™çš„æ‰€æœ‰ä¸­ç‚¹å€¼
        values = []
        for i in range(n_alt):
            val = weighted[i, k]
            if isinstance(val, Interval):
                values.append(val.midpoint)
            else:
                values.append(float(val))

        # æ ¹æ®å‡†åˆ™æ–¹å‘ç¡®å®šç†æƒ³è§£
        if criteria[k].direction == "higher_better":
            max_val = max(values)
            min_val = min(values)
        else:
            max_val = min(values)
            min_val = max(values)

        ideal.append(max_val)
        negative_ideal.append(min_val)
```

#### 3. _calculate_distances

```python
def _calculate_distances(self, weighted, ideal, negative_ideal, alternatives):
    """è®¡ç®—åˆ°ç†æƒ³è§£å’Œè´Ÿç†æƒ³è§£çš„è·ç¦»"""
    for i, alt in enumerate(alternatives):
        sum_squared_ideal = 0.0
        sum_squared_negative = 0.0

        for k in range(n_crit):
            val = weighted[i, k]
            if isinstance(val, Interval):
                midpoint = val.midpoint
            else:
                midpoint = float(val)

            # åˆ°ç†æƒ³è§£çš„è·ç¦»å¹³æ–¹
            diff_ideal = midpoint - ideal[k]
            sum_squared_ideal += diff_ideal ** 2

            # åˆ°è´Ÿç†æƒ³è§£çš„è·ç¦»å¹³æ–¹
            diff_negative = midpoint - negative_ideal[k]
            sum_squared_negative += diff_negative ** 2

        # æ¬§æ°è·ç¦»
        distance_to_ideal[alt] = math.sqrt(sum_squared_ideal)
        distance_to_negative_ideal[alt] = math.sqrt(sum_squared_negative)
```

---

## ğŸ“Š æ¡ˆä¾‹åˆ†æ

### äº‘æœåŠ¡æä¾›å•†é€‰æ‹©

**åœºæ™¯**: æŸå…¬å¸éœ€è¦é€‰æ‹©äº‘æœåŠ¡æä¾›å•†

**å¤‡é€‰æ–¹æ¡ˆ**: AWS, Azure, GCP

**å‡†åˆ™**:
1. æ€§èƒ½ï¼ˆæ•ˆç›Šå‹ï¼Œæƒé‡ 0.4ï¼‰
2. æˆæœ¬ï¼ˆæˆæœ¬å‹ï¼Œæƒé‡ 0.3ï¼‰
3. å¯é æ€§ï¼ˆæ•ˆç›Šå‹ï¼Œæƒé‡ 0.2ï¼‰
4. æ˜“ç”¨æ€§ï¼ˆæ•ˆç›Šå‹ï¼Œæƒé‡ 0.1ï¼‰

**åŒºé—´è¯„åˆ†**:

| æä¾›å•† | æ€§èƒ½ | æˆæœ¬ | å¯é æ€§ | æ˜“ç”¨æ€§ |
|--------|----------------------|---------------------|----------------------|----------------------|
| AWS    | [80, 90]            | [50, 70]            | [85, 95]            | [75, 85]            |
| Azure  | [85, 95]            | [40, 60]            | [80, 90]            | [80, 90]            |
| GCP    | [82, 92]            | [60, 80]            | [75, 85]            | [70, 80]            |

### è®¡ç®—è¿‡ç¨‹

#### 1. ä¸­ç‚¹è½¬æ¢

| æä¾›å•† | æ€§èƒ½ | æˆæœ¬ | å¯é æ€§ | æ˜“ç”¨æ€§ |
|--------|------|------|--------|--------|
| AWS    | 85   | 60   | 90     | 80     |
| Azure  | 90   | 50   | 85     | 85     |
| GCP    | 87   | 70   | 80     | 75     |

#### 2. Vector æ ‡å‡†åŒ–

è®¡ç®—å„å‡†åˆ™çš„èŒƒæ•°ï¼š
- æ€§èƒ½: $\sqrt{85^2 + 90^2 + 87^2} = \sqrt{23134} \approx 152.10$
- æˆæœ¬: $\sqrt{60^2 + 50^2 + 70^2} = \sqrt{11000} \approx 104.88$
- å¯é æ€§: $\sqrt{90^2 + 85^2 + 80^2} = \sqrt{21825} \approx 147.74$
- æ˜“ç”¨æ€§: $\sqrt{80^2 + 85^2 + 75^2} = \sqrt{19450} \approx 139.46$

æ ‡å‡†åŒ–çŸ©é˜µï¼š

| æä¾›å•† | æ€§èƒ½ | æˆæœ¬ | å¯é æ€§ | æ˜“ç”¨æ€§ |
|--------|------|------|--------|--------|
| AWS    | 0.559| 0.572| 0.609  | 0.574  |
| Azure  | 0.592| 0.477| 0.575  | 0.610  |
| GCP    | 0.572| 0.667| 0.541  | 0.538  |

#### 3. åŠ æƒæ ‡å‡†åŒ–

| æä¾›å•† | æ€§èƒ½ (w=0.4) | æˆæœ¬ (w=0.3) | å¯é æ€§ (w=0.2) | æ˜“ç”¨æ€§ (w=0.1) |
|--------|-------------|-------------|---------------|---------------|
| AWS    | 0.224       | 0.172       | 0.122         | 0.057         |
| Azure  | 0.237       | 0.143       | 0.115         | 0.061         |
| GCP    | 0.229       | 0.200       | 0.108         | 0.054         |

#### 4. ç†æƒ³è§£/è´Ÿç†æƒ³è§£

| ç±»å‹ | æ€§èƒ½ | æˆæœ¬ | å¯é æ€§ | æ˜“ç”¨æ€§ |
|------|------|------|--------|--------|
| ç†æƒ³è§£   | 0.237 | 0.143 | 0.122 | 0.061 |
| è´Ÿç†æƒ³è§£ | 0.224 | 0.200 | 0.108 | 0.054 |

æ³¨æ„ï¼šæˆæœ¬æ˜¯æˆæœ¬å‹ï¼Œæ‰€ä»¥ç†æƒ³è§£å–æœ€å°å€¼

#### 5. è·ç¦»è®¡ç®—

**AWS**:
- $D^+ = \sqrt{(0.224-0.237)^2 + (0.172-0.143)^2 + (0.122-0.122)^2 + (0.057-0.061)^2} \approx 0.032$
- $D^- = \sqrt{(0.224-0.224)^2 + (0.172-0.200)^2 + (0.122-0.108)^2 + (0.057-0.054)^2} \approx 0.032$

**Azure**:
- $D^+ \approx 0.029$, $D^- \approx 0.057$

**GCP**:
- $D^+ \approx 0.057$, $D^- \approx 0.032$

#### 6. ç›¸å¯¹æ¥è¿‘åº¦

- AWS: $C = 0.032 / (0.032 + 0.032) = 0.500$
- Azure: $C = 0.057 / (0.029 + 0.057) = 0.663$
- GCP: $C = 0.032 / (0.057 + 0.032) = 0.360$

#### 7. æœ€ç»ˆæ’å

1. Azure (0.663)
2. AWS (0.500)
3. GCP (0.360)

---

## ğŸ¯ ç®—æ³•ä¼˜åŠ¿ä¸å±€é™

### ä¼˜åŠ¿

1. **ç›´è§‚**: åŸºäºè·ç¦»çš„æ¦‚å¿µï¼Œæ˜“äºç†è§£
2. **æ— å‚æ•°**: ä¸éœ€è¦è®¾ç½®é¢å¤–çš„ç®—æ³•å‚æ•°
3. **å®Œå…¨æ’åº**: æä¾›å®Œæ•´çš„æ–¹æ¡ˆæ’åº
4. **ç¨³å®šæ€§**: å¯¹æ•°æ®å˜åŒ–ç›¸å¯¹ç¨³å®š
5. **æ ‡å‡†åŒ–**: Vector æ ‡å‡†åŒ–æ¶ˆé™¤é‡çº²å½±å“

### å±€é™

1. **è·ç¦»åº¦é‡**: æ¬§æ°è·ç¦»å¯èƒ½ä¸é€‚ç”¨äºæ‰€æœ‰åœºæ™¯
2. **çº¿æ€§è¡¥å¿**: å…è®¸å‡†åˆ™é—´çš„å®Œå…¨è¡¥å¿
3. **ä¸­ç‚¹ç®€åŒ–**: åŒºé—´ç‰ˆæœ¬ä½¿ç”¨ä¸­ç‚¹ï¼Œå¯èƒ½ä¸¢å¤±éƒ¨åˆ†ä¿¡æ¯
4. **ç†æƒ³è§£ä¾èµ–**: å¯¹æç«¯å€¼æ•æ„Ÿ

### é€‚ç”¨åœºæ™¯

âœ… **é€‚åˆä½¿ç”¨ TOPSIS**:
- éœ€è¦å®Œæ•´æ’åºçš„åœºæ™¯
- æ–¹æ¡ˆæ•°é‡è¾ƒå¤šï¼ˆ>3ï¼‰
- å‡†åˆ™é—´å­˜åœ¨è¡¥å¿å…³ç³»
- æ•°æ®è´¨é‡è¾ƒå¥½

âŒ **ä¸é€‚åˆä½¿ç”¨ TOPSIS**:
- éœ€è¦è®¾ç½®åå¥½é˜ˆå€¼
- å‡†åˆ™é—´ä¸å…è®¸å®Œå…¨è¡¥å¿
- æ•°æ®å­˜åœ¨æç«¯å¼‚å¸¸å€¼
- éœ€è¦ä¿ç•™å®Œæ•´çš„åŒºé—´ä¿¡æ¯

---

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Hwang, C. L., & Yoon, K. (1981). "Multiple Attribute Decision Making: Methods and Applications". Springer.
2. Yoon, K. (1987). "A reconciliation among discrete compromise situations". Journal of the Operational Research Society.
3. Jahanshahloo, G. R., et al. (2006). "Extension of TOPSIS for decision-making problems with interval data". Applied Mathematics and Computation.
4. Opricovic, S., & Tzeng, G. H. (2004). "Compromise solution by MCDM methods: A comparative analysis of VIKOR and TOPSIS". European Journal of Operational Research.

---

**æœ€åæ›´æ–°**: 2026-02-04
**ç‰ˆæœ¬**: v0.8.1
**ä½œè€…**: AI (Claude Sonnet 4.5)
